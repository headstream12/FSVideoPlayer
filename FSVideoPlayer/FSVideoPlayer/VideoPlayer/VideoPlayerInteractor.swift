//
//  VideoPlayerInteractor.swift
//  fschool_ios
//
//  Created Ilya Glazunov on 14/06/2018.
//  Copyright © 2018 Altarix. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit
import GoSwiftyM3U8

class VideoPlayerInteractor: VideoPlayerInteractorInputProtocol {
    var urls: [VideoPlayerInteractor.Resolution: URL] = [:]
    
    weak var presenter: VideoPlayerInteractorOutputProtocol?
    
    enum Resolution: String {
        case low = "640x360"
        case medium = "854х480"
        case hd = "1280x720"
        case fullHd = "1920x1080"
    }
    
    func chooseResolution(_ resolution: VideoPlayerInteractor.Resolution) {
    }
    
    func parsePlaylistWithUrl(_ url: URL) {
        let manager = M3U8Manager()
        let params = PlaylistOperation.Params(fetcher: nil, url: url, playlistType: .master)
        let operationData = M3U8Manager.PlaylistOperationData(params: params, extraParams: nil)
        let playlistType = MasterPlaylist.self
        manager.fetchAndParsePlaylist(from: operationData, playlistType: playlistType) { [unowned self] result in
            switch result {
            case .success(let playlist):
                playlist.tags.streamTags.forEach {
                    if let url = URL(string: $0.uri) {
                        self.urls[Resolution.init(rawValue: $0.resolution) ?? .fullHd] = url
                    }
                }
                DispatchQueue.main.async {
                    if self.urls.count > 0 {
                        self.presenter?.onParseUrlSuccess(preferredResolutionUrl: self.getPreferredResolutionUrl())
                    } else {
                        let error = NSError(domain: "Empty m3u8 file", code: 301, userInfo: nil)
                        self.presenter?.onParseUrlError(error)
                    }
                }
            case .failure(let error):
                DispatchQueue.main.async {
                    self.presenter?.onParseUrlError(error!) //TODO: Разобраться с error
                }
            case .cancelled: break
            }
        }
    }
    
    func getPreferredResolutionUrl() -> URL {
        let connectionType = NetworkConnectionStatus.getCurrentConnectionType()
        
        switch connectionType {
        case .wwan2g:
            if let preferredUrl = self.urls[.low] {
                return preferredUrl
            } else {
                return self.urls.first!.value
            }
        case .wwan3g:
            if let preferredUrl = self.urls[.medium] {
                return preferredUrl
            } else {
                return self.urls.first!.value
            }
        case .wwan4g:
            if let preferredUrl = self.urls[.hd] {
                return preferredUrl
            } else {
                return self.urls.first!.value
            }
        case .wifi:
            if let preferredUrl = self.urls[.fullHd] {
                return preferredUrl
            } else {
                return self.urls.first!.value
            }
        default:
            return self.urls.first!.value
        }
    }
}

